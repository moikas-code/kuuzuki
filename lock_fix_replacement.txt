
    // Acquire lock early to prevent race conditions
    let abortSignal;
    try {
      abortSignal = lock(input.sessionID);
    } catch (error) {
      // If session is locked, queue the request
      if (error instanceof BusyError) {
        return new Promise((resolve) => {
          const queue = state().queued.get(input.sessionID) ?? [];
          queue.push({
            input: input,
            message: userMsg,
            parts: userParts,
            processed: false,
            callback: resolve,
          });
          state().queued.set(input.sessionID, queue);
        });
      }
      // Re-throw other errors
      throw error;
    }

